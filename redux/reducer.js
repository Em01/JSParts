
/*A reducer is a function that returns a piece of the applications state.
Because the app may have many different pieces of state, we can have many different reducers.
Reducers producer the value of our state.
Application state is generated by reducers
A function that produces the value of our state

{
books: [{title: 'A title'}], //Books reducer
activeBook: {title: 'Another title} // Active books reducer
*/


//A reducer is only ever called when an action occurs
//All reducers get two arguments
//Accepts the State and Action as arguments and returns the next state.
//state is not application state only the state that this reducer is responsible for

const counter = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT': 
      return state - 1;
    default: 
      return state;
  }
}

expect(
    counter(0, {type: 'INCREMENT'})
).toEqual(1);

//mj assertion library
//When you pass a counter of 0 state with the increment action you expect 1.

expect(
    counter(1, {type: 'INCREMENT'})
).toEqual(2);

expect(
    counter(2, {type: 'DECREMENT'})
).toEqual(1);

//TO WIRE IN A REDUCER

import { combineReducers } from 'redux'

const rootReducer = combineReducers({
  books: bookReducer
});

export rootReducer;


//if we dont care about the action then just return state

export default function(state, action) {
  return state;
}

//state = null guards against undefined

export default function(state = null, action) {
  switch(action.type) {
    case 'BOOK_SELECTED':
      return action.payload;
    }
  return state;
}

//guard against empty props if app has just started and state is null-
render() {
  if(!this.props.title) {
    return <div></div>
  }
}

//the key in combineReducers is the property of state that you are reducing:
export default combineReducers({
  auth: AuthReducer
})
//So the Auth piece of state is produced by the Auth reducer

//Whatever value is returned from the reducer will end up as the applications state.

//after reducer returns the new state redux compares the new and the old state. It only updates if a change has ocurred. same object in memory so we have to return something that makes redux think it has made a change.
